<script>
/*
	1. 코드흐름 : 
		* Array Parser함수를 만든다! 
			- 문자열을 인자로 받는다. 
			- 문자열 안에는 배열 형태로 되어 있다.
			- 배열형태로 되어있는 문자열을 배열로 만들어준다.
			- 배열의 형태로 변경된 문자열을 type과 value와 child를 분석한다!!
			- 분석할 때 숫자형이 아닌 다른 type들도 분석하고 올바른 문자열이 아니면 오류를 발생시킨다.
	2. 함수명, 변수명 설정 : 
		1. str : 배열의 형태로 된 문자열이다.
		2. pipe함수 : pipe함수로 여러 함수들을 인자로 받아 첫번째함수의 리턴값을 두번째함수의 
		인자값으로 받고 두번째 함수의 리턴값을 세번째함수의 인자값으로 받아 쭉 실행한다.
		3. arrayFromString : 문자열에서 문자한개한개가 원소값인 배열을 만들어준다. 공백은 제거한다. 맨앞의 "["와 맨끝의 "]"는 제거한다.
		4. checkObjectType : 문자열안에서 객체안에 배열이 있는지 배열안에 객체가 있는 지 객체형태로 합쳐줄 지 배열형태로 합쳐줄지를 체크해준다.
		5. combineElements : 한개한개문자열에서 배열형태의 문자 "["과 "]"과 객체형태의 "{"과 "}" 있다면 그 사이에 있는 문자인 원소를 하나의 문자열로 합쳐준다.
		6. makeElement : ','이라는 문자를 기준으로 문자를 합쳐 문자열을 만들어주고 그 문자열을 원소값으로 가지는 배열을 만든다.
		7. makeObject : ':'라는 문자열을 기준으로 key값과 value값을 구분하고 ','를 기준으로 원소와 원소를 구분하여 객체를 만든다.
		8. changeStringToArray : 3번과 5번과 6번은 pipe함수로 연결하여 changeStringToArray함수를 만들어준다.
		9. changeStringToObject : 3번과 5번과 7번을 pipe함수로 연결하여 changeStringToObject함수를 만들어준다.
		10. arrayParser : str을 인자로 받아 type과 value와 child를 분석한다!
		11. child : 배열메소드 reduce는 함수를 인자로 받는데 인자로 받을 함수이다. 객체나 배열의 child원소를 분석한다. 
		12. typeCheck : number형 이외에도 string, null, boolean, undefined 타입들을 분석한다.
		13. errorCheck : 3d3과 같은 알 수 없는 타입과 "'1a'3'"올바르지 않은 문자열과 같은 경우 오류메시지를 출력한다.
		14. jsonParser : Object타입도 type, key, value 값을 분석한다.

	3. 특징이 비슷한 함수끼리 class로 묶는다.
		1. changeString : 문자열을 파싱할 수 있게 배열이나 배열로 바꿔주는 클래스이다.
			- arrayFromString
			- checkObjectType
			- combineElements
			- makeElement
			- makeObject
			- changeStringToArray
			- changeStringToObject
		
		2. parser : 분석을 하는 클래스이다. 모든 타입을 분석하고 객체나 배열은 child를 또 분석한다.
			- typeCheck
			- arrayParser
			- child
			- jsonParser
		
		3. error : 에러를 체크하는 클래스이다. 에러상황이 많기 때문에 따로 class로 분류하였다.
			- errorCheck
*/
class changeString{

	arrayFromString(str){

		let newArray = Array.from(str)
		newArray = newArray.slice(1,newArray.length - 1);
		return newArray;
	}
	checkObjectType(newArray){

		if(newArray.includes("{")&&newArray.includes("[")){
			return newArray.indexOf("{") > newArray.indexOf("[") ? ["[","]"] : ["{","}"];
		}
		if(newArray.includes("["))return ["[","]"];
		if(newArray.includes("{"))return ["{","}"];
		return false;
	}
	combineElements(newArray){

		const check = this.checkObjectType(newArray);
		if( !check )return newArray;

		const dic = newArray.reduce( (prev, curr, i ) => {
			if( curr === check[0] || curr === check[1] ){
				prev[i] = curr;
				return prev;
			}else{ return prev; }
		},{});
		let count = 0;
		for( let key in dic ){
			if( dic[key] === check[0]) count++;
			if( dic[key] === check[1]) count--;
			if( count === 0 ){
				const startIndex = newArray.indexOf(check[0]);
				const lastIndex = +key;
				const changeString = newArray.slice(startIndex, lastIndex+1).reduce( (prev, curr) => prev+curr);
				newArray.splice(startIndex, changeString.length, changeString);
				return this.combineElements(newArray);
			}
		}

	}
	makeElement(newArray){

		let valueOfArray = "";
		const makeElement = [];
		for(let i = 0; i < newArray.length; i++){
			if(newArray[i] === ","){
				makeElement.push(valueOfArray.trim());
				valueOfArray = "";
				continue;
			}
			valueOfArray += newArray[i];
		}
		makeElement.push(valueOfArray.trim());
		return makeElement;

	}


	makeObject(newArray){

		let keyOfObject = "";
		let dic = {};
		let result = "";
		for(let i = 0; i < newArray.length; i++){
			if( newArray[i] === ":"){
				keyOfObject = result.trim();
				result = "";
				continue;
			}
			if( newArray[i] === ","){
				dic[keyOfObject] = result.trim();
				result = "";
				continue;
			}
			result += newArray[i];
		}
		dic[keyOfObject] = result.trim();

		return dic;
	}
	changeStringToArray(str){
		return pipe(this.arrayFromString,this.combineElements, this.makeElement)(this, str);
	}
	changeStringToObject(str){
		return pipe(this.arrayFromString,this.combineElements, this.makeObject)(this, str);
	}
}

class parser{
	constructor(parsableType, errorCheck){
		this.parsableType = parsableType;
		this.errorCheck = errorCheck.errorCheck;
	}
	typeCheck(value){
		if(!isNaN(+value))return "number";
		const dic = {
			true : "boolean",
			false : "boolean",
			undefined : "undefined",
			null : "null"
		}
		for(let key in dic){
			if( key === value ) return dic[key];
		}
		return "string";
	}
	arrayParser(str,key){

		let result;
		if(typeof str === "string"){
			const parsingArray = this.parsableType.changeStringToArray(str);
			let dic = {};
			dic.type = "array";
			if(!!key)dic.key = key;
			dic.value = "ArrayObject";
			dic.child = this.arrayParser(parsingArray);
			result = dic;
		}else{
			result = str.reduce(this.child.bind(this), []);
		}
		return result;

	}

	child(prev, curr){

		if(curr[0] === "["){
			return prev.concat(this.arrayParser(curr)); 
		}else if(curr[0] === "{"){
			return prev.concat(this.jsonParser(curr));
		}else{
			const typeOfValue = this.typeCheck(curr);
			if(typeOfValue === "string")this.errorCheck(curr);
			let dic = {};
			dic.type = typeOfValue;
			dic.value = curr;
			dic.child = [];
			return prev.concat(dic);
		}
	}

	jsonParser(str){

		let result;
		if(typeof str === "string"){
			const parsingObject = this.parsableType.changeStringToObject(str);
			let dic = {};
			dic.type = "object";
			dic.value = "object Object";
			dic.child = this.jsonParser(parsingObject);
			result = dic;
		}else{
			result = [];
			for(let key in str){
				if(str[key][0] === "["){
					result = result.concat(this.arrayParser(str[key],key));
				}else if(str[key][0] === "{"){
					result.concat(this.jsonParser(str[key]))
				}else{
					const typeOfValue = this.typeCheck(str[key]);
					let dic = {};
					dic.type = typeOfValue;
					if(typeOfValue === "string")this.errorCheck(str[key]);
					dic.key = key;
					dic.value = str[key];
					dic.child = [];
					result.push(dic);
				}
			}
		}
		return result;
	}

}
class error{
	errorCheck(value){
		if( value.match(/\'/) === null ) throw value + "은 알 수 없는 타입입니다.";
		if( !!value.slice(1,value.length-1).match(/\'/)) throw value + "은 올바른 문자열이 아닙니다.";
	}
}


const pipe = (...fns) => (objName,value) => fns.reduce( (acc, fn) => fn.call(objName, acc), value);
let str = "['1a3',[null,false,['11',[112233],{easy : ['hello', {a:'a'}, 'world']},112],55, '99'],{a:'str', b:[912,[5656,33],{key : 'innervalue', newkeys: [1,2,3,4,5]}]}, true]";
const errorCheck = new error();
const changedParsableType = new changeString();
const parseData = new parser(changedParsableType, errorCheck);
console.log(JSON.stringify(parseData.arrayParser(str), null, 2));

// str = "['1a'3',[22,23,[11,[112233],112],55],33]";
// console.log(JSON.stringify(parseData.arrayParser(str), null, 2));

// str = "['1a3',[22,23,[11,[112233],112],55],3d3]"; 
// console.log(JSON.stringify(parseData.arrayParser(str), null, 2));

// str = "['1a3',[22,23,[11,[112233],112],55],{crong : 3d3}]"; 
// console.log(JSON.stringify(parseData.arrayParser(str), null, 2));

// str = "[{a : '1a'3'},[22,23,[11,[112233],112],55],33]";
// console.log(JSON.stringify(parseData.arrayParser(str), null, 2));
</script>