<script>
/*
	1. 코드흐름 : 
		* Array Parser함수를 만든다! 
			- 문자열을 인자로 받는다. 
			- 문자열 안에는 배열 형태로 되어 있다.
			- 배열형태로 되어있는 문자열을 배열로 만들어준다.
			- 배열의 형태로 변경된 문자열을 type과 value와 child를 분석한다!!
			- 분석할 때 숫자형이 아닌 다른 type들도 분석하고 올바른 문자열이 아니면 오류를 발생시킨다.
	2. 함수명, 변수명 설정 : 
		1. str : 배열의 형태로 된 문자열이다.
		2. pipe함수 : pipe함수로 여러 함수들을 인자로 받아 첫번째함수의 리턴값을 두번째함수의 
		인자값으로 받고 두번째 함수의 리턴값을 세번째함수의 인자값으로 받아 쭉 실행한다.
		3. arrayFromString : 문자열에서 문자한개한개가 원소값인 배열을 만들어준다. 공백은 제거한다. 맨앞의 "["와 맨끝의 "]"는 제거한다.
		4. combineElements : 한개한개문자열에서 배열형태의 문자 "["과 "]"이 있다면 그 사이에 있는 문자인 원소를 하나의 문자열로 합쳐준다.
		5. makeElement : ','이라는 문자를 기준으로 문자를 합쳐 문자열을 만들어주고 그 문자열을 원소값으로 가지는 배열을 만든다.
		6. changeStringToArray : 3번과 4번과 5번은 pipe함수로 연결하여 changeStringToArray을 만들어준다.
		7. arrayParser : str을 인자로 받아 type과 value와 child를 분석한다!
		8. typeCheck : number형 이외에도 string, null, boolean, undefined 타입들을 분석한다.
		9. errorCheck : 3d3과 같은 알 수 없는 타입과 "'1a'3'"올바르지 않은 문자열과 같은 경우 오류메시지를 출력한다.

*/

const pipe = (...fns) => (value) => fns.reduce( (acc, fn) => fn(acc), value);

function arrayFromString(str){

	let newArray = Array.from(str)
	newArray = newArray.slice(1,newArray.length - 1);
	return newArray;
}

function combineElements(newArray){

	if( !newArray.includes("[") )return newArray;
	const dic = newArray.reduce( (prev, curr, i ) => {
		if( curr === "[" || curr === "]" ){
			prev[i] = curr;
			return prev;
		}else{ return prev; }
	},{});
	let count = 0;
	for( let key in dic ){
		if( dic[key] === "[") count++;
		if( dic[key] === "]") count--;
		if( count === 0 ){
			const startIndex = newArray.indexOf("[");
			const lastIndex = +key;
			const changeString = newArray.slice(startIndex, lastIndex+1).reduce( (prev, curr) => prev+curr);
			newArray.splice(startIndex, changeString.length, changeString);
			return combineElements(newArray);
		}
	}

}

function makeElement(newArray){

	let valueOfArray = "";
	let makeElement = [];
	for(let i = 0; i < newArray.length; i++){
		if(newArray[i] === ","){
			makeElement.push(valueOfArray.trim());
			valueOfArray = "";
			continue;
		}
		valueOfArray += newArray[i];
	}
	makeElement.push(valueOfArray.trim());
	return makeElement;

}

const changeStringToArray = pipe(arrayFromString, combineElements, makeElement);

function arrayParser(str){

	let result;
	if(typeof str === "string"){
		const parsingArray = changeStringToArray(str);
		let dic = {};
		dic.type = "array";
		dic.value = "ArrayObject"
		dic.child = arrayParser(parsingArray);
		result = dic;
	}else{
		result = str.reduce(child, []);
	}
	return result;

}

function child(prev, curr){

	if(curr[0] === "["){
		return prev.concat(arrayParser(curr));
	}else{
		const typeOfValue = typeCheck(curr);
		if(typeOfValue === "string")errorCheck(curr);
		let dic = {};
		dic.type = typeOfValue;
		dic.value = curr;
		dic.child = [];
		return prev.concat(dic);
	}
}

function typeCheck(value){
	if(!isNaN(+value))return "number";
	const dic = {
		true : "boolean",
		false : "boolean",
		undefined : "undefined",
		null : "null"
	}
	for(let key in dic){
		if( key === value ) return dic[key];
	}
	return "string";
}

function errorCheck(value){
	if( value.match(/\'/) === null ) throw value + "은 알 수 없는 타입입니다."
	if( !!value.slice(1,value.length-1).match(/\'/)) throw value + "은 올바른 문자열이 아닙니다.";
}

let str = "['1a3',[null,false,['11',[112233],112],55, '99'],33, true]";
let result = arrayParser(str);
console.log(JSON.stringify(result, null, 2));

str = "['1a'3',[22,23,[11,[112233],112],55],33]";
result = arrayParser(str);
str = "['1a3',[22,23,[11,[112233],112],55],3d3]";
result = arrayParser(str);
str = "['1a3',[null,fa   lse,['11',[112233],112],55, '99'],33, true]";
result = arrayParser(str);
str = "[   '1a3'  ,   true   , '55'  ,  33  ]";
result = arrayParser(str);
console.log(JSON.stringify(result, null, 2));
</script>