# javascript-json
레벨2

* step3 무한배열중첩구조 해결
1. 문자열이 주어졌을때, 우선 그 문자열을 의미가 있는 토큰별로 나눈다. 예시 : '[11,22,33,[44,55]]' => '[','11','22','33','[','44','55',']',']'
1. 토큰별로 분석하며 만약 '[' 가 나온다면 새로운 배열을 만들도록 한다.
1. ']'가 나온다면 만든 배열을 child값에 넣어준다.
1. 이를 수행하기 위해 두개의 클래스로 나누어준다. 토큰화해주는 객체, 토큰을 분석해주는 객체

* step4 타입체크
1. tokenize는 그대로, Analyze에 스텝에 필요한 모든 조건을 넣을것.
1. t,f,',n (true, false, string, null)이 4개의 첫번째 글자를 이용해서 type을 분류할 것.
1. 토큰마다 오류를 탐지하는 함수에 넣어 토큰에 이상이 있는지 확인할 것.
1. 함수는 한가지만의 일을 하도록 노력해볼 것.
1. 5번째 라인의 의문. errorCheck라는 객체를 만들어서 type은 구별할 수 있으니까, type마다의 에러를 체크하면 되지 않을까?

* step5 객체 값 확인하기
1. 토큰나누기를 할때, '{' 값과 '}' 값을 따로 나눔,:는 key값과 같이 있을 수 있도록 나눔
"{'dominate':13}"를 나눈걸 예시로들면 ['{','dominate:','13','}']이런 형식으로 나눌 수 있도록. ':'값이 존재하면 ':'값 이전까지 type이 object key인 value 값에 넣어 주도록 하고,
child는 '[]' 로 넣어줄 수 있도록 한다.

1. 분석을 할때, { 값이 나오면 새로운 제이슨 데이터를 만들도록. child에는 getChild가 여전히 들어가도록 하고, { 다음에 오는 값은 무조건 ':' 를 포함하고 있을 테니, 그값만 key로 만들고
뒤의 값은 이전과 같은 방식으로 만들 수 있도록 하기. 언제까지? '}'가 나올때 까지.

* step6 오류상황 탐지

* 오류상황 case
  1. 배열이 안 닫혔을 때
  1. 객체가 안 닫혔을 때 
  1. :가 없을 때
  1. 값 없이 ','만 두 개 찍혔을 때
  1. 객체일 때 key 값은 없고 value값만 있을 때
  1. 객체일 때 value값은 없고 key값만 있을 때 

1. 배열이 안 닫혔을 때 
   * [의 갯수와]의 갯수를 세어 같지 않다면 에러 반환
1. 객체가 안 닫혔을 때
   * {의 갯수와}의 갯수를 세어 같지 않다면 에러 반환
1. : 가 없을때
   * {가온다면 새로운 배열을 만듬. :를 찾기위한거니까 {가 나올때마다 새로하나씩 만들어도 상관 없음. :가 나올때 갯수를 세서 넣음. 만약 :가 없이 }가 나온다면 에러 반환
1. 값 없이 ','만 두개 찍혔을 때
   * ,의 바로 다음 값에 , 가 있을 경우 에러 반환
1. 객체일 때 key 값은 없고 value값만 있을 때
   * {다음 값이 바로 :일 때 에러 반환
1. 객체일 때 value값은 없고 key값만 있을 때
   * :바로 다음값이 ,이거나 }일때 에러 반환

=> 3, 5, 6의 갯수가 모두 같아야 조건이 맞다!
checkError를 먼저 실행하고 모든 조건이 맞아 떨어질 때 코드를 실행해 줄 수 있도록 한다.
실행순서 : 문자열 전체의 에러체크, 없다면 코드실행
설계상 오류. {의 갯수와 : 갯수가 같을리가...
그럼이제 {}내에 : 값이 없을 때, 5번일때, 6번일때 모두의 경우를 생각해야함...
그냥 문자열을 처음부터 끝까지 검사한다는 것보다 토큰화된 배열을 탐색해야함.
굳이 복사된 토큰배열을 여러개 만들것이 아니라, 복사된 토큰 하나로 모든 에러를 체크하며 나아가...는것보다 그냥 다 복사해서 하자. 복사하지 않고 하면 객체안의 배열, 배열안의 객체를 판단하기 힘들어짐.
